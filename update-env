#!/usr/bin/env bash

# Naming Policy:
#
# All function and variable names are camelCased, but variable names may begin with
# uppercase letters.
#
# Local variable names begin with lowercase letters.
# Global variable names begin with uppercase letters.
# (Global variable names are not namespaced by suffixing them with a randomly-generated
# letter because this script is the library consumer.)
#
# Locally-defined task functions are suffixed with "Task".

CrostiniDir=/mnt/chromeos/MyFiles/Downloads/crostini

main() {
  set -euo pipefail   # enable strict mode
  setSafeExpansionMode on

  platform=$(platform)
  [[ $platform == crostini ]] && {
    section system
    aptUpgradeTask
  }

  # copy non-passphrased key if it exists and there isn't already a key
  if [[ -e $CrostiniDir/np_id_ed25519.pub ]]; then
    section credential
    task.Install 600 $CrostiniDir/np_id_ed25519 ~/.ssh/id_ed25519
    task.Install 644 $CrostiniDir/np_id_ed25519.pub ~/.ssh/id_ed25519.pub
  # copy unique key if it exists and there isn't already a key
  elif [[ -e $CrostiniDir/id_ed25519.pub ]]; then
    section credential
    task.Install 600 $CrostiniDir/id_ed25519 ~/.ssh/id_ed25519
    task.Install 644 $CrostiniDir/id_ed25519.pub ~/.ssh/id_ed25519.pub
  fi

  section dotfiles
  task.GitClone git@github.com:binaryphile/dotfiles ~/dotfiles
  case $platform in
    crostini  ) task.Ln contexts/crostini ~/dotfiles/context;;
    macos     ) task.Ln contexts/macos ~/dotfiles/context;;
  esac

  section nix
  curlPipeLixInstallerTask
  chownRTask /nix $(id -u) $(id -g)
  loosely source /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
  task.Ln ~/dotfiles/config.nix ~/.config/nixpkgs/config.nix

  section home-manager
  nixChannelAddHomeManagerTask
  nixChannelUpdateTask
  nixShellHomeManagerInstallTask
  loosely source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
  task.Ln ~/dotfiles/home.nix ~/.config/home-manager/home.nix
  homeManagerSwitchTask

  [[ $platform == crostini ]] && {
    section crostini
    task.Ln $CrostiniDir ~/crostini

    # link to permanent project directories from home dir
    stream $(glob $CrostiniDir/{flakes,projects,GolandProjects,obsidian}/*) |
      map target '$target ~/${target#$CrostiniDir/}' |
      each task.Ln
  }

  section mk.bash
  task.GitClone git@github.com:binaryphile/mk.bash ~/projects/mk.bash
  task.GitCheckout develop ~/projects/mk.bash
  task.Ln ~/projects/mk.bash/mk.bash ~/.local/lib/mk.bash
  task.Ln ~/projects/mk.bash/mk-example ~/.local/bin/mk
  PATH+=:~/.local/bin

  section neovim
  task.GitClone git@github.com:binaryphile/dot_vim ~/.config/nvim
  curlTask https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim ~/.local/share/nvim/site/autoload/plug.vim
  nvimHeadlessPlugInstallTask
  task.Ln ~/.config/nvim ~/nvim

  section task.bash
  task.GitClone git@github.com:binaryphile/task.bash ~/projects/task.bash
  task.GitCheckout develop ~/projects/task.bash

  section tesht
  task.GitClone git@github.com:binaryphile/tesht ~/projects/tesht
  task.GitCheckout develop ~/projects/tesht
  task.Ln ~/projects/tesht/tesht ~/.local/bin/tesht

  section apps
  task.GitClone git@bitbucket.org:accelecon/tlilley-daily-notes ~/obsidian/tlilley-daily-notes
  each task.Ln <<'  END'
    .config                                       ~/config
    .local                                        ~/local
    .ssh                                          ~/ssh
    ~/dotfiles/bash/init.bash                     ~/.bash_profile
    ~/dotfiles/bash/init.bash                     ~/.bashrc
    ~/dotfiles/bash/init.bash                     ~/.profile
    ~/dotfiles/gitconfig                          ~/.gitconfig
    ~/dotfiles/liquidprompt/liquid.theme          ~/.config/liquidprompt/liquid.theme
    ~/dotfiles/liquidprompt/liquidpromptrc        ~/.config/liquidpromptrc
    ~/dotfiles/ranger/rc.conf                     ~/.config/ranger/rc.conf
    ~/dotfiles/ranger/rifle.conf                  ~/.config/ranger/rifle.conf
    ~/dotfiles/ssh/config                         ~/.ssh/config
    ~/dotfiles/tmux.conf                          ~/.tmux.conf
    ~/projects/task.bash/update-env               ~/.local/bin/update-env
  END

  [[ $platform == crostini ]] && {
    section unique_credential
    [[ -e $CrostiniDir/np_id_ed25519.pub ]] && {
      removeMatchingFileTask ~/.ssh/id_ed25519.pub $CrostiniDir/np_id_ed25519.pub
      removeMatchingFileTask ~/.ssh/id_ed25519 $CrostiniDir/np_id_ed25519
      rm $CrostiniDir/np_id_ed25519{,.pub}
    }
    sshKeygenTask $CrostiniDir/id_ed25519
    task.Install 600 $CrostiniDir/id_ed25519 ~/.ssh/id_ed25519
    task.Install 644 $CrostiniDir/id_ed25519.pub ~/.ssh/id_ed25519.pub
  }

  task.Summarize
  echo

  # update all project git repositories
  # not a task, so not part of the summary
  task.IsShortRun || mk git-update $(glob ~/{GolandProjects,obsidian,projects}/*)
}

## task definitions

# system

# aptUpgradeTask upgrades all apt packages to latest.
# It first does an apt update.
aptUpgradeTask() {
  desc   'apt upgrade'
  prog   on
  runas  root
  unchg  '0 upgraded, 0 newly installed'
  cmd    'apt update -qq && apt upgrade -y'
}

# nix

curlPipeLixInstallerTask() {
  desc   'install single-user nix'
  prog   on
  exist  /nix/var/nix/profiles/default/bin/nix-env
  cmd    'curl -sSf -L https://install.lix.systems/lix | sh -s -- install linux --no-confirm --init none'
}

# chownRTask recursively chowns $path with $user:$group.
# $user and $group are the numbered versions, e.g. 1000:1000, not username:groupname.
chownRTask() {
  local path=$1 user=$2 group=$3
  printf -v path %q $path

  desc    "recursively change ownership of $path to $user:$group"
  runas   root
  ok      "[[ \$(ownerAndGroup $path) == $user:$group ]]"
  cmd     "chown -R -- $user:$group $path"
}

# home manager

nixChannelAddHomeManagerTask() {
  desc   'add home manager channel'
  exist  ~/.nix-channels
  cmd    'nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager'
}

nixChannelUpdateTask() {
  desc   'update nix channels'
  prog   on
  exist  ~/.nix-defexpr/channels/home-manager
  cmd    'nix-channel --update'
}

nixShellHomeManagerInstallTask() {
  desc   'install home manager'
  prog   on
  exist  ~/.config/home-manager
  cmd    "nix-shell '<home-manager>' -A install"
}

homeManagerSwitchTask() {
  desc  'apply home manager configuration'
  prog  on
  unchg 'No change so reusing latest profile generation'
  cmd   'home-manager switch'
}

# neovim

curlTask() {
  local url=$1 filename=$2
  desc   "download ${url##*/} from ${url%/*} as $(basename $filename)"
  exist  $filename
  cmd    "mkdir -p -- $(dirname $filename); curl -fsSL -- $url >$filename"
}

nvimHeadlessPlugInstallTask() {
  desc  'install neovim plugins'
  exist ~/.local/share/nvim/plugged
  cmd   'nvim --headless +PlugInstall +qall'
}

# credential

removeMatchingFileTask() {
  local targetFilename=$1 matchFilename=$2
  desc  "remove file $targetFilename if it matches $matchFilename"
  ok    "[[ -e $matchFilename ]] && ! [[ -e $targetFilename ]] || [[ \$(<$targetFilename) != \$(<$matchFilename) ]]"
  cmd   "
    if [[
      -e $matchFilename && -e $targetFilename &&
      \$(<$targetFilename) == \$(<$matchFilename)
    ]]; then
      rm $targetFilename
    fi
  "
}

sshKeygenTask() {
  local keyFilename=$1
  desc  'generate an ssh key'
  prog  on
  ok    "[[ -e $keyFilename ]]"
  cmd   "
    read -sp 'generating ssh key.  passphrase: ' passphrase
    read -sp $'\nagain: ' passphrase2
    [[ \$passphrase == \$passphrase2 ]] || { echo -e '\npassphrase did not match'; exit 1; }
    echo
    ssh-keygen -t ed25519 -f $keyFilename -N \"\$passphrase\" -C \$USER@\$(host)
    cat $keyFilename.pub
  "
}

## helpers

fatal() {
  local msg=$1 rc=${2:-$?}
  echo "fatal: $msg"
  exit $rc
}

# glob path-expands its arguments and echoes them as a list.
# It employs nullglob, so an unmatched glob is empty, not returned as the original pattern string.
glob() {
  local globbingWasOn=0 nullGlobWasOn=0
  [[ $- != *f* ]] && globbingWasOn=1 || set +o noglob  # or enable globbing by disabling noglob
  [[ $(shopt nullglob) == *on ]] && nullGlobWasOn=1 || shopt -s nullglob   # or enable nullglob

  local results=( $* )
  echo "${results[*]}"

  (( globbingWasOn )) || set -o noglob   # or disable globbing by enabling noglob
  (( nullGlobWasOn )) || shopt -u nullglob   # or disable nullglob
}

host() {
  [[ $HOSTNAME == penguin && -e $CrostiniDir/hostname ]] && cat $CrostiniDir/hostname
  echo $HOSTNAME
}

loosely() {
  setSafeExpansionMode off
  set +euo pipefail
  "$@"
  set -euo pipefail
  setSafeExpansionMode on
}

ownerAndGroup() {
  local path=$1
  [[ $OSTYPE == darwin* ]] && local flag=f || local flag=c
  echo $(stat -$flag %u $path):$(stat -$flag %g $path)
}

platform() {
  [[ $OSTYPE != darwin* ]] || { echo macos; return; }
  [[ $HOSTNAME != penguin ]] || { echo crostini; return; }
  echo linux
}

section() { echo -e "\n[section $1]"; }

# setSafeExpansionMode disables word-splitting on space|tab and path expansion (globbing).
# An argument of "on" enables it and any other argument disables it,
# restoring the behavior of before it was invoked.
# It does not maintain a stack, so it cannot be invoked on multiple times in a row without
# losing the original behavior from before it was invoked.
setSafeExpansionMode() {
  case $1 in
    on )
      OldIFS=$IFS
      IFS=$'\n'
      [[ $- == *f* ]] && OldGlob=- || OldGlob=+
      set -o noglob
      ;;
    * )
      IFS=$OldIFS
      set ${OldGlob}o noglob
      ;;
  esac
}

## fp

# each applies its arguments as a command to each argument from stdin.
each() {
  local command=$1 arg
  while IFS='' read -r arg; do
    eval "$command $arg"
  done
}

# map returns $expression evaluated with the value of stdin as $varname.
# $expression must respect double-quoting rules and so can't contain naked quotes.
# $varname may not be "varname" or "expression".
map() {
  local varname=$1 expression=$2
  case $varname in varname|expression ) fatal "map: varname may not be 'varname' or 'expression'";; esac
  local $varname
  while IFS='' read -r $varname; do
    eval "echo \"$expression\""
  done
}

# stream echoes arguments escaped and separated by newline.
stream() {
  local arg
  for arg in $*; do
    printf '%q\n' $arg
  done
}

## boilerplate

here=$(cd "$(dirname "$BASH_SOURCE")"; cd -P "$(dirname "$(readlink "$BASH_SOURCE" || echo .)")"; pwd)
if [[ -e "$here"/task.bash ]]; then
  source "$here"/task.bash
else
  lib=$(curl -fsSL https://raw.githubusercontent.com/binaryphile/task.bash/main/task.bash) || exit
  eval "$lib"
fi
unset -v here lib

return 2>/dev/null  # stop here if sourced, for interactive debugging

# parse options
while [[ ${1:-} == -?* ]]; do
  case $1 in
    -h|--help )   [[ -v Usage ]] && echo "$Usage"; exit;;

    -x|--trace )  set -x;;

    -s|--short )  task.SetShortRun;;

    -- ) shift; break;;
  esac
  shift
done

main
